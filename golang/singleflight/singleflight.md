# golang å•é£žæ¨¡å¼
> èšåˆç›¸åŒå·¥ä½œçš„ä¸€ç§ä¼˜åŒ–æ€è·¯

ç»„ç»‡:

1. èƒŒæ™¯
2. ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å•é£žæ¨¡å¼
3. ä»€ä¹ˆåœºæ™¯ä¸‹ä½¿ç”¨å•é£žæ¨¡å¼
4. å¦‚ä½•å®žçŽ°ä¸€ä¸ªå•é£žæ¨¡å¼
5. æ€»ç»“

## èƒŒæ™¯
åœ¨ä½¿ç”¨ç¼“å­˜çš„åœºæ™¯ä¸­ï¼Œä¼šé‡åˆ°è¿™æ ·ä¸€ç§æƒ…å†µï¼Œä¸€ä¸ªè¾ƒçƒ­é—¨çš„ key åœ¨ç¼“å­˜ä¸­è¿‡æœŸäº†ï¼Œæ¯”è¾ƒåŽ‹æŠ‘çš„æ˜¯ï¼Œæ­¤æ—¶æœ‰è¾ƒå¤šå®¢æˆ·ç«¯åŒæ—¶å‘èµ·äº†å¯¹è¿™ä¸ª key çš„è®¿é—®ã€‚æ˜¯çš„ï¼Œè¿™æ˜¯ä¸ªç»å…¸çš„ç¼“å­˜ç©¿é€çš„é—®é¢˜ã€‚é¢å¯¹è¿™ç§åœºæ™¯ï¼Œè¾ƒä¸ºå¸¸è§çš„åšæ³•æ˜¯ï¼Œ é‡‡ç”¨å…ˆæ¥å…ˆæœåŠ¡çš„åŽŸåˆ™ï¼Œé™åˆ¶å®¢æˆ·ç«¯å›žæºæ•°æ®åº“æˆ–è€…å…¶ä»–æ•°æ®æºï¼Œè¿™ç§åšæ³•æ¯‹åº¸ç½®ç–‘å‡è½»äº†æ•°æ®åº“çš„åŽ‹åŠ›ï¼Œä½†æ˜¯è¿™ç§åšæ³•å¯¹éœ€è¦èŽ·å–æ•°æ®çš„å®¢æˆ·ç«¯çœŸçš„å¥½å—ï¼Ÿ

å¤„ç†é€»è¾‘å›¾å¯èƒ½æ˜¯è¿™æ ·çš„: // todo 

å…¶å®žä»”ç»†æƒ³æƒ³ï¼Œå¤šä¸ªå®¢æˆ·ç«¯åŒæ—¶è¯·æ±‚ç›¸åŒçš„keyï¼Œåªæœ‰ä¸€ä¸ªå®¢æˆ·ç«¯æœ‰è¿”å›žï¼Œå…¶ä»–çš„å®¢æˆ·ç«¯éƒ½æ²¡æœ‰èƒ½èŽ·å–åˆ°æ­£ç¡®çš„æ•°æ®ï¼Œè¿™ä¸ªè®¾è®¡å¯¹æ•°æ®åº“æ˜¯å¥½çš„ï¼Œä½†æ˜¯è¿˜æœ‰æ²¡æœ‰å…¶ä»–çš„æ–¹æ¡ˆæ—¢èƒ½åŒæ—¶ä¿æŠ¤æ•°æ®åº“åˆèƒ½ä½¿å¾—ä¸åŒçš„å®¢æˆ·ç«¯å¯¹åŒä¸€ä¸ªkeyçš„è®¿é—®èƒ½å¤ŸèŽ·å–åˆ°æœ‰æ•ˆæ•°æ®å‘¢ï¼Ÿ

## ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å•é£žæ¨¡å¼

åŸºäºŽå‰è¿°çš„èƒŒæ™¯ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œæˆ‘ä»¬å¸¸ç”¨çš„æ–¹æ¡ˆè§£å†³äº†å¤§é‡çš„å®¢æˆ·ç«¯åŒæ—¶è®¿é—®åŒä¸€ä¸ª key çš„æ—¶å€™ï¼Œå¯¹å®¢æˆ·ç«¯åšè®¿é—®æ•°é‡ä¸Šçš„é™åˆ¶æ˜¯ä¿æŠ¤äº†æ•°æ®åº“ï¼Œä½†æ˜¯å¯¹äºŽå®¢æˆ·ç«¯äº†è¯´ï¼Œå¤§å¤šæ•°æ˜¯èŽ·å–ä¸åˆ°æœ‰æ•ˆçš„æ•°æ®çš„ã€‚

å¸¸ç”¨çš„è§£å†³æ–¹æ¡ˆæœ‰:
1. é™åˆ¶å®¢æˆ·ç«¯å¯¹æ•°æ®åº“åŒæ—¶è®¿é—®çš„æ•°é‡ï¼Œåªæ”¾è¡Œä¸€ä¸ªå®¢æˆ·ç«¯å›žæºæ•°æ®åº“ï¼Œå°†èŽ·å–åˆ°çš„æ•°æ®ä¿å­˜åˆ°ç¼“å­˜
2. å¯¹äºŽå¤§å¤šæ•°çš„è¯·æ±‚å®¢æˆ·ç«¯è¿”å›žæ²¡æœ‰èŽ·å–åˆ°æ•°æ®
3. æ²¡æœ‰èŽ·å–åˆ°æ•°æ®çš„å®¢æˆ·ç«¯é‡æ–°å¯¹æœåŠ¡å™¨å‘èµ·ä¸€ä¸ªè¯·æ±‚ï¼Œç›´åˆ°èŽ·å–åˆ°æ•°æ®ä¸ºæ­¢

è¿™ä¸ªè¿‡ç¨‹çš„é—®é¢˜å‡ºçŽ°åœ¨å“ªäº†ï¼Ÿ
å¯¹äºŽæ²¡æœ‰èŽ·å–åˆ°è®¿é—®æ•°æ®åº“æƒé™çš„å®¢æˆ·ç«¯ç›´æŽ¥è¿”å›žï¼Œç„¶åŽé‡æ–°å‘èµ·å¯¹æ•°æ®çš„è¯·æ±‚ã€‚

ä¸ºäº†æ–¹ä¾¿æè¿°ï¼Œåšäº†å¦‚ä¸‹çš„å®šä¹‰:

**A ç±»å®¢æˆ·ç«¯: æœ‰æƒé™å›žæºæ•°æ®åº“çš„å®¢æˆ·ç«¯**

**B ç±»å®¢æˆ·ç«¯: æ²¡æœ‰æƒé™å›žæºæ•°æ®åº“çš„å®¢æˆ·ç«¯**

å…¶å®žå¯¹äºŽ B ç±»å®¢æˆ·ç«¯ï¼Œåœ¨æ²¡æœ‰èŽ·å–åˆ°å¯¹æ•°æ®åº“çš„è®¿é—®æƒé™ä¹‹åŽï¼Œæ˜¯ä¸æ˜¯å¯ä»¥ç­‰å¾… A ç±»å®¢æˆ·ç«¯çš„è¿”å›žå€¼å‘¢ï¼Ÿ
åšåˆ°äº†è¿™ä¸€æ­¥ä¹‹åŽï¼Œç„¶åŽå°±æ²¡æœ‰ç¬¬ 3 æ­¥äº†ã€‚

æœ€åŽè§£å†³æ–¹æ¡ˆæŠ½è±¡æˆäº†:

1. é™åˆ¶å®¢æˆ·ç«¯å¯¹æ•°æ®åº“åŒæ—¶è®¿é—®çš„æ•°é‡ï¼Œåªæ”¾è¡ŒA ç±»å®¢æˆ·ç«¯å›žæºæ•°æ®åº“ï¼Œå°†èŽ·å–åˆ°çš„æ•°æ®ä¿å­˜åˆ°ç¼“å­˜
2. Bç±»å®¢æˆ·ç«¯å…±äº«Aç±»å®¢æˆ·ç«¯è¯·æ±‚çš„æ•°æ®ï¼Œç„¶åŽè¿”å›ž

åšåˆ°è¿™é‡Œï¼ŒB ç±»å®¢æˆ·ç«¯å†æ¬¡å¯¹æœåŠ¡å™¨å‘èµ·è¯·æ±‚çš„æ•°é‡æ˜Žæ˜¾å‡å°‘äº†ï¼Œå¹¶ä¸”æŽ¥å£è¯·æ±‚çš„æˆåŠŸçŽ‡æ˜Žæ˜¾æé«˜äº†

å°ç»“: ä½¿ç”¨å•é£žæ¨¡å¼ä¸»è¦æ˜¯ä¿æŠ¤æ•°æ®åº“å’Œå‡å°‘å®¢æˆ·ç«¯è¯·æ±‚çš„æ¬¡æ•°

## ä»€ä¹ˆåœºæ™¯ä¸‹ä½¿ç”¨å•é£žæ¨¡å¼

åœ¨ *ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å•é£žæ¨¡å¼* ä½¿ç”¨äº†ä¸€ä¸ªæ¯”è¾ƒé€‚åˆä½¿ç”¨å•é£žæ¨¡å¼è§£å†³é—®é¢˜çš„åœºæ™¯ï¼Œä½†æ˜¯ï¼Œåˆ°åº•å•é£žæ¨¡å¼å¯ä»¥é€‚ç”¨äºŽå“ªäº›åœºæ™¯å‘¢ï¼Ÿ è¿˜æ˜¯ä»¥ä¸Šè¿°çš„ä¸ºä¾‹å­ã€‚

``` text

1. é™åˆ¶å®¢æˆ·ç«¯å¯¹æ•°æ®åº“åŒæ—¶è®¿é—®çš„æ•°é‡ï¼Œåªæ”¾è¡ŒA ç±»å®¢æˆ·ç«¯å›žæºæ•°æ®åº“ï¼Œå°†èŽ·å–åˆ°çš„æ•°æ®ä¿å­˜åˆ°ç¼“å­˜
2. Bç±»å®¢æˆ·ç«¯å…±äº«Aç±»å®¢æˆ·ç«¯è¯·æ±‚çš„æ•°æ®ï¼Œç„¶åŽè¿”å›ž
```

æ­¥éª¤ 1 ä¸»è¦æ˜¯å¤šä¸ªå®¢æˆ·ç«¯åŒæ—¶å¯¹äºŽåŒä¸€ä¸ªèµ„æºçš„è®¿é—®ï¼Œä¸ºäº†å‡å°‘èµ„æºæä¾›æ–¹çš„åŽ‹åŠ›ï¼Œåªå…è®¸ä¸€ä¸ªå®¢æˆ·ç«¯çš„å›žæºã€‚

æ­¥éª¤ 2 æˆåŠŸå›žæºçš„å®¢æˆ·ç«¯å’Œå…¶ä»–å®¢æˆ·ç«¯å…±äº«èŽ·å–åˆ°çš„æ•°æ®

æ€»ç»“: A ç±»å®¢æˆ·ç«¯ç›¸å½“äºŽåšäº†ä¸€ä¸ªè‹¦åŠ›çš„æ´»ï¼Œç„¶åŽAç±»å®¢æˆ·ç«¯ä¸ŽBç±»å®¢æˆ·ç«¯å…±äº«æ•°æ®çš„åœºæ™¯æ˜¯æ¯”è¾ƒé€‚åˆä½¿ç”¨å•é£žæ¨¡å¼çš„ã€‚

åœºæ™¯æ¯”å¦‚: CDN èµ„æºå›žæºä¸»ç«™ï¼Œredis ç¼“å­˜ç©¿é€(éƒ½æ˜¯å¤šä¸ªå®¢æˆ·ç«¯å¯¹åŒä¸€ä¸ªèµ„æºçš„åŒæ—¶è®¿é—®çš„åœºæ™¯)ç­‰ç­‰


## å¦‚ä½•å®žçŽ°ä¸€ä¸ªå•é£žæ¨¡å¼

å®žçŽ°ä¸€ä¸ªå•é£žæ¨¡å¼çš„åº•å±‚éœ€è¦æ³¨æ„çš„ç‚¹: 
1. å¯¹äºŽ A ç±»å®¢æˆ·ç«¯: éœ€è¦åŽ»å®Œæˆå¯¹æ•°æ®çš„è®¿é—®ï¼Œå†è¯·æ±‚å¤„ç†å®Œæ¯•ä¹‹åŽï¼Œéœ€è¦é€šçŸ¥ B ç±»å®¢æˆ·ç«¯æ•°æ®å·²ç»èŽ·å–å®Œæ¯•

2. å¯¹äºŽB ç±»å®¢æˆ·ç«¯: åœ¨æ²¡æœ‰èŽ·å–åˆ°å·¥ä½œçš„æƒé™ä¹‹åŽåˆ™éœ€è¦ç­‰å¾… A ç±»å®¢æˆ·ç«¯è¿”å›žçš„æ•°æ®

3. å¯¹äºŽå·²ç»ä¸éœ€è¦çš„ä»»åŠ¡ï¼Œåº•å±‚éœ€è¦åšè‡ªåŠ¨é‡Šæ”¾çš„å¤„ç†

> ä»¥ go è¯­è¨€ä¸º ðŸŒ°

```go
package singleflight

import (
	"fmt"
	"sync"
	"sync/atomic"
)

type Result struct {
	Value interface{}
	Err   error
}

type Group struct {
	mu     sync.Mutex       
	single map[string]*call 
}

func NewGroup() *Group {
	return &Group{}
}

type call struct {
	result interface{}   
	err    error        
	done   chan struct{} 
	refJob int32        
}

func (c *Group) DoChan(key string, execute func() (interface{}, error)) <-chan Result {
	r := make(chan Result)
	c.mu.Lock()
	defer c.mu.Unlock()
	var ca *call
	var ok bool
	if ca, ok = c.single[key]; !ok {
		ca = &call{done: make(chan struct{})}
		// if single is nil
		if c.single == nil {
			c.single = make(map[string]*call)
		}
		c.single[key] = ca
		// æ‰§è¡Œå·¥ä½œä»»åŠ¡
		go func() {
			defer func() {
				if err := recover(); err != nil {
					fmt.Errorf("execute panic:%s", err)
				}
			}()
			ca.result, ca.err = execute()
            // è¯·æ±‚å·²ç»å®Œæˆ, é€šçŸ¥ Bç±»å®¢æˆ·ç«¯
			ca.done <- struct{}{}
			close(ca.done)
		}()
	}
	// add job ref
	atomic.AddInt32(&ca.refJob, 1)

	go func() {
        // ç­‰å¾… A ç±»å®¢æˆ·ç«¯çš„æ•°æ®
		<-ca.done
		r <- Result{Err: ca.err, Value: ca.result} // return job result
		close(r)
		if atomic.AddInt32(&ca.refJob, -1) == 0 { // è‡ªå®šé‡Šæ”¾ä»»åŠ¡
			c.deleteJob(key, ca)
		}
	}()

    // è¿”å›žä¸€ä¸ªåªè¯»çš„ channel 
	return r
}

func (c *Group) DoCall(key string, execute func() (interface{}, error)) Result {
	r := c.DoChan(key, execute)
	return <-r
}

func (c *Group) deleteJob(key string, ca *call) {
	c.mu.Lock()
	if atomic.LoadInt32(&ca.refJob) == 0 {
		delete(c.single, key)
	}
	c.mu.Unlock()
}

```
è‡³æ­¤ï¼Œä¸€ä¸ªç®€å•çš„å•é£žæ¨¡å¼å°±å¯ç”¨äº†ã€‚

## æ€»ç»“ 

æ€»çš„æ¥è¯´ï¼Œå•é£žæ¨¡å¼åœ¨åŒæ—¶å¤„ç†å¤šä¸ªå®¢æˆ·ç«¯çš„ç›¸åŒå·¥ä½œæ–¹é¢ä¸Šæœ‰ä¸€å®šä¸Šçš„ä¼˜åŠ¿ã€‚å…¶åŽŸç†ç›¸å¯¹ç®€å•ï¼Œç”±äºŽ go è¯­è¨€çš„ä¼˜åŠ¿ï¼Œåœ¨å®žçŽ°è¿™ä¸€å—çš„é€»è¾‘ä¸šåŠ¡ä»£ç ç›¸å¯¹ä¸å¤æ‚ï¼Œæ€§èƒ½ä»£ä»·ä¹Ÿæ˜¯æ¯”è¾ƒå°çš„ã€‚


one more,
å¯¹äºŽä¸åŒçš„æ–¹æ¡ˆåœ¨æ€§èƒ½å’Œæ•ˆçŽ‡æ–¹é¢ä¸Šçš„å½±å“
