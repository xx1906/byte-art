# go 语言中的错误处理

## 楼起

> 由于需要追溯程序的运行轨迹，开发者总是会在关键的处理上打上日志，用于追溯程序运行的轨迹以及排查错误
> 当然了，这中方式在 go 中也是适用的，但是 在 go 中没有像 java 那种 `try/catch` 的异常处理机制，
> 但是 go 中支持多返回值， 以及 `panic` 处理。

由于没有一种办法来限制开发者在程序中的日志输出。所以对于错误处理也一行，之前对于错误的处理是 在发生错误的地方打印日志
在接收错误的地方也打印错误的日志，其实仔细想想这两个地方的日志其实是一样的啊，**起码错误输出的内容是一样的**

但是在我们排查问题的时候， 只需要知道程序在哪里出错，以及出错时的传入参数就好了，输出重复的日志的作用反而不到。
```go
package main

import (
	"errors"
	"fmt"
)

// 数据层处理数据
func div(a, b int) (ans int, err error) {
	if b == 0 {
    // 打印错误并且返回
		fmt.Println("div by zero")
		return 0, errors.New("div by zero")
	}
	return a / b, nil
}

// 业务的逻辑处理
func biz(a, b int) (ans int, err error) {
	ans, err = div(a, b)
	if err != nil {
    // 但印上一层的错误， 并且继续返回
		fmt.Println(err)
	}
	return
}

func main() {
	// service
	ans, err := biz(233, 0)
	if err != nil {
		fmt.Println("err ", err)
	}
	fmt.Println("ans:", ans)
}

```
要是能还原完成的函数调用链就好了。

## 峰回

这个事情得回到 `go1.13` (不记得了，忘记了，真的忘记了)

秉持着巨佬说的: 在 go 中， 对于错误应该只处理一次, 然后采用了社区中较为流行的包 [github.com/pkg/errors](https://pkg.go.dev/github.com/pkg/errors#section-documentation) 

```go
package main

import (
	"fmt"
	"github.com/pkg/errors"
)

// 数据层处理数据
func div(a, b int) (ans int, err error) {
	if b == 0 {
		return 0, errors.New("div by zero")
	}
	return a / b, nil
}

// 业务的逻辑处理
func biz(a, b int) (ans int, err error) {
	ans, err = div(a, b)
	if err != nil {
		err = errors.WithMessage(err, fmt.Sprintf("a:%d, b:%d", a, b))
	}
	return
}

func main() {
	// service
	ans, err := biz(233, 0)
	if err != nil {
		fmt.Printf("err %+v", err)
	}
	fmt.Println("ans:", ans)
}

```
## 落定
程序遇到错误的时候， 使用 `pkg/errors` 包下的 `errors.New` 方法可以程序的函数调用链路包裹进来

